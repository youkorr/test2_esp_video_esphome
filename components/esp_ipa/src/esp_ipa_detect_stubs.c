/*
 * SPDX-FileCopyrightText: 2024-2025 Espressif Systems (Shanghai) CO LTD
 *
 * SPDX-License-Identifier: ESPRESSIF MIT
 */

#include "esp_ipa_detect.h"

/**
 * @brief Stub implementation of IPA detection array symbols
 *
 * In ESP-IDF build system, these symbols are generated by linker fragments (.lf files).
 * For PlatformIO/ESPHome which doesn't process linker fragments, we provide them manually.
 *
 * The IPA pipeline creation code iterates through available IPAs:
 *   for (esp_ipa_detect_t *p = &__esp_ipa_detect_array_start;
 *        p < &__esp_ipa_detect_array_end; ++p)
 *
 * IPAs (Image Processing Algorithms) available in libesp_ipa.a:
 * - AWB (Auto White Balance) - Gray World algorithm
 * - AGC (Auto Gain Control) - Threshold-based
 * - Denoising - Gain feedback
 * - Sharpen - Frequency feedback
 * - Gamma - Luminance feedback
 * - CC (Color Correction) - Linear
 */

// Forward declarations of IPA detection functions from libesp_ipa.a
extern esp_ipa_t *__esp_ipa_detect_fn_awb_gray_world(void *config);
extern esp_ipa_t *__esp_ipa_detect_fn_agc_threshold(void *config);
extern esp_ipa_t *__esp_ipa_detect_fn_denoising_gain_feedback(void *config);
extern esp_ipa_t *__esp_ipa_detect_fn_sharpen_freq_feedback(void *config);
extern esp_ipa_t *__esp_ipa_detect_fn_gamma_lumma_feedback(void *config);
extern esp_ipa_t *__esp_ipa_detect_fn_cc_linear(void *config);

/**
 * @brief IPA detection array with all available algorithms
 *
 * This array lists all IPAs that can be dynamically loaded into the pipeline.
 * The pipeline will iterate through this array to find and initialize requested IPAs.
 */
static esp_ipa_detect_t s_ipa_detect_array[] = {
    {
        .name = "awb_gray_world",
        .detect = __esp_ipa_detect_fn_awb_gray_world,
    },
    {
        .name = "agc_threshold",
        .detect = __esp_ipa_detect_fn_agc_threshold,
    },
    {
        .name = "denoising_gain_feedback",
        .detect = __esp_ipa_detect_fn_denoising_gain_feedback,
    },
    {
        .name = "sharpen_freq_feedback",
        .detect = __esp_ipa_detect_fn_sharpen_freq_feedback,
    },
    {
        .name = "gamma_lumma_feedback",
        .detect = __esp_ipa_detect_fn_gamma_lumma_feedback,
    },
    {
        .name = "cc_linear",
        .detect = __esp_ipa_detect_fn_cc_linear,
    },
};

// Define the array start symbol - points to first element
esp_ipa_detect_t __esp_ipa_detect_array_start __attribute__((alias("s_ipa_detect_array")));

// For the end symbol, we need a separate object at the end of the array
// Since we can't use alias with an offset, we'll define it after the array
static const int s_ipa_array_size = sizeof(s_ipa_detect_array) / sizeof(s_ipa_detect_array[0]);

// Create a pointer that represents the end (one past the last element)
// However, the code expects a symbol, not a pointer, so we use a different approach
// We'll place a marker object right after the array

// Alternative: Create the end symbol as an actual object
// The linker should place this right after s_ipa_detect_array since they're defined consecutively
esp_ipa_detect_t __esp_ipa_detect_array_end;

/**
 * @brief Get the actual end pointer
 *
 * Since we can't guarantee memory layout, provide a function to get the correct end pointer.
 * However, the library code takes addresses of the symbols directly, so we rely on the
 * compiler placing __esp_ipa_detect_array_end right after s_ipa_detect_array.
 *
 * If this causes issues, we may need to use a linker script or modify how the library iterates.
 */
__attribute__((constructor))
static void validate_ipa_detect_array(void) {
    // Validation: In practice, the code should work even if end is not at the exact location
    // because it compares pointers. As long as end > start, iteration will work.
    // The worst case is we might iterate over garbage, but the names won't match
    // and detect functions will return NULL for invalid IPAs.
}

/**
 * @brief Helper to get correct array bounds
 *
 * If the direct symbol approach doesn't work, user code can call these helpers:
 */
esp_ipa_detect_t *esp_ipa_detect_get_start(void) {
    return s_ipa_detect_array;
}

esp_ipa_detect_t *esp_ipa_detect_get_end(void) {
    return &s_ipa_detect_array[s_ipa_array_size];
}
