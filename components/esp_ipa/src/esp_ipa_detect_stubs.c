/*
 * SPDX-FileCopyrightText: 2024-2025 Espressif Systems (Shanghai) CO LTD
 *
 * SPDX-License-Identifier: ESPRESSIF MIT
 */

#include "esp_ipa_types.h"

/**
 * @brief Stub implementation of IPA detection array symbols
 *
 * In ESP-IDF, these symbols are generated by linker fragments (.lf files).
 * For PlatformIO/ESPHome, we provide them manually.
 *
 * The IPA pipeline code iterates: for (p = &start; p < &end; ++p)
 * We use numbered subsections (.esp_ipa_detect.N) to guarantee ordering.
 *
 * Available IPAs in libesp_ipa.a:
 * - AWB: Auto White Balance (Gray World)
 * - AGC: Auto Gain Control (Threshold)
 * - Denoising: Gain feedback
 * - Sharpen: Frequency feedback
 * - Gamma: Luminance feedback
 * - CC: Color Correction (Linear)
 */

// Forward declarations from libesp_ipa.a
extern esp_ipa_t *__esp_ipa_detect_fn_awb_gray_world(void *config);
extern esp_ipa_t *__esp_ipa_detect_fn_agc_threshold(void *config);
extern esp_ipa_t *__esp_ipa_detect_fn_denoising_gain_feedback(void *config);
extern esp_ipa_t *__esp_ipa_detect_fn_sharpen_freq_feedback(void *config);
extern esp_ipa_t *__esp_ipa_detect_fn_gamma_lumma_feedback(void *config);
extern esp_ipa_t *__esp_ipa_detect_fn_cc_linear(void *config);

// Define the structure type used for detection
typedef struct esp_ipa_detect {
    const char *name;
    esp_ipa_t *(*detect)(void *);
} esp_ipa_detect_t;

/**
 * IPA detection array using numbered subsections for guaranteed order
 *
 * The linker will sort .esp_ipa_detect.0, .esp_ipa_detect.1, etc. in numerical order.
 * We create __esp_ipa_detect_array_start and __esp_ipa_detect_array_end directly.
 */

// Start marker - must be first (subsection .0)
__attribute__((used, section(".esp_ipa_detect.00000")))
esp_ipa_detect_t __esp_ipa_detect_array_start = {
    .name = "awb_gray_world",
    .detect = __esp_ipa_detect_fn_awb_gray_world,
};

__attribute__((used, section(".esp_ipa_detect.00001")))
static esp_ipa_detect_t esp_ipa_detect_agc_threshold = {
    .name = "agc_threshold",
    .detect = __esp_ipa_detect_fn_agc_threshold,
};

__attribute__((used, section(".esp_ipa_detect.00002")))
static esp_ipa_detect_t esp_ipa_detect_denoising_gain_feedback = {
    .name = "denoising_gain_feedback",
    .detect = __esp_ipa_detect_fn_denoising_gain_feedback,
};

__attribute__((used, section(".esp_ipa_detect.00003")))
static esp_ipa_detect_t esp_ipa_detect_sharpen_freq_feedback = {
    .name = "sharpen_freq_feedback",
    .detect = __esp_ipa_detect_fn_sharpen_freq_feedback,
};

__attribute__((used, section(".esp_ipa_detect.00004")))
static esp_ipa_detect_t esp_ipa_detect_gamma_lumma_feedback = {
    .name = "gamma_lumma_feedback",
    .detect = __esp_ipa_detect_fn_gamma_lumma_feedback,
};

__attribute__((used, section(".esp_ipa_detect.00005")))
static esp_ipa_detect_t esp_ipa_detect_cc_linear = {
    .name = "cc_linear",
    .detect = __esp_ipa_detect_fn_cc_linear,
};

// End marker - must be last (subsection .99999)
__attribute__((used, section(".esp_ipa_detect.99999")))
esp_ipa_detect_t __esp_ipa_detect_array_end = {
    .name = NULL,
    .detect = NULL,
};
